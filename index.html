<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Tracker (Versión 8.0)</title>
  <style>
    body {
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .form-group {
      margin-bottom: 15px;
    }
    .form-group label {
      display: block;
      margin-bottom: 5px;
    }
    .form-group input, .form-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: white;
    }
    .button-blue { background-color: #007bff; }
    .button-blue:hover { background-color: #0056b3; }
    .button-green { background-color: #28a745; }
    .button-green:hover { background-color: #218838; }
    .button-red { background-color: #dc3545; }
    .button-red:hover { background-color: #c82333; }
    .button-gray { background-color: #6c757d; }
    .button-gray:hover { background-color: #5a6268; }
    .error { color: red; }
    .success { color: green; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .flex { display: flex; gap: 10px; align-items: center; }
    .platform-highlight { color: red; }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 500px;
      width: 100%;
      position: relative;
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="libs/react.min.js"></script>
  <script src="libs/react-dom.min.js"></script>
  <script src="libs/babel.min.js"></script>
  <script src="libs/dexie.min.js"></script>
  <script src="libs/papaparse.min.js"></script>
  <script type="text/babel">
    const { useState, useEffect } = React;

    console.log('Iniciando aplicación...');
    console.log('💡 Consejo: Para detectar cambios en el código automáticamente y recargar el navegador sin cerrar sesión, usa "live-server" en lugar de "http-server". Instálalo con "npm install -g live-server", luego ejecuta "live-server" en la carpeta "media-tracker". Esto recargará la página automáticamente cuando hagas cambios en "index.html".');

    // Inicializar IndexedDB con Dexie
    let db;
    try {
      db = new Dexie('MediaTrackerDB');
      db.version(2).stores({
        users: 'id,name,email,password',
        media: 'id,userId,title,type,platform,genre,duration,status,rating',
        seasons: 'id,mediaId,seasonNumber,episodeCount,totalDuration',
        episodes: 'id,seasonId,episodeNumber,duration,watched',
        platforms: 'name'
      }).upgrade(async (trans) => {
        console.log('Ejecutando migración de datos para la versión 2...');
        const media = await trans.table('media').toArray();
        const existingPlatforms = [...new Set(media.map(m => m.platform))].filter(p => p);
        const defaultPlatforms = ['Netflix', 'Prime', 'Disney', 'Paramount'];
        const allPlatforms = [...new Set([...defaultPlatforms, ...existingPlatforms])];
        await trans.table('platforms').bulkAdd(allPlatforms.map(name => ({ name })));
        console.log('Plataformas migradas:', allPlatforms);
      });
      console.log('IndexedDB inicializado correctamente');
    } catch (err) {
      console.error('Error al inicializar IndexedDB:', err);
    }

    // Generar ID único sin uuid
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

    // Lista de géneros
    const genres = [
      'Acción', 'Aventura', 'Animación', 'Ciencia Ficción', 'Comedia', 'Crimen',
      'Documental', 'Drama', 'Fantasía', 'Historia', 'Horror', 'Misterio',
      'Romance', 'Suspenso', 'Western', 'Otro'
    ];

    // Tiempo de expiración de la sesión (en milisegundos): 30 minutos
    const SESSION_TIMEOUT = 30 * 60 * 1000;

    // Función para actualizar la última actividad del usuario
    const updateLastActivity = () => {
      const now = Date.now();
      localStorage.setItem('lastActivity', now.toString());
      console.log('Última actividad actualizada:', new Date(now).toISOString());
    };

    // Función para verificar si la sesión ha expirado
    const hasSessionExpired = () => {
      const lastActivity = localStorage.getItem('lastActivity');
      if (!lastActivity) return true; // Si no hay última actividad, la sesión ha expirado
      const now = Date.now();
      const timeSinceLastActivity = now - parseInt(lastActivity, 10);
      console.log('Tiempo desde la última actividad:', timeSinceLastActivity / 1000, 'segundos');
      return timeSinceLastActivity > SESSION_TIMEOUT;
    };

    // Componente principal
    function App() {
      const [user, setUser] = useState(null);
      const [view, setView] = useState('login');
      const [error, setError] = useState('');

      // Restaurar sesión al iniciar la aplicación
      useEffect(() => {
        const restoreSession = async () => {
          console.log('Intentando restaurar sesión...');
          const userId = localStorage.getItem('userId');
          if (userId) {
            try {
              const storedUser = await db.users.get(userId);
              if (storedUser) {
                if (hasSessionExpired()) {
                  console.log('Sesión expirada, limpiando datos...');
                  localStorage.removeItem('userId');
                  localStorage.removeItem('lastActivity');
                  setError('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
                } else {
                  setUser(storedUser);
                  setView('dashboard');
                  updateLastActivity();
                  console.log('Sesión restaurada para usuario:', storedUser);
                }
              } else {
                console.log('No se encontró usuario con ID:', userId);
                localStorage.removeItem('userId');
                localStorage.removeItem('lastActivity');
              }
            } catch (err) {
              console.error('Error al restaurar sesión:', err);
              localStorage.removeItem('userId');
              localStorage.removeItem('lastActivity');
            }
          } else {
            console.log('No se encontró userId en localStorage');
          }
        };
        restoreSession();
      }, []);

      // Registrar eventos de actividad del usuario (clics, teclas, etc.)
      useEffect(() => {
        const handleActivity = () => {
          if (user) { // Solo actualizar si hay un usuario logueado
            updateLastActivity();
          }
        };

        window.addEventListener('click', handleActivity);
        window.addEventListener('keydown', handleActivity);
        window.addEventListener('mousemove', handleActivity);

        return () => {
          window.removeEventListener('click', handleActivity);
          window.removeEventListener('keydown', handleActivity);
          window.removeEventListener('mousemove', handleActivity);
        };
      }, [user]);

      useEffect(() => {
        console.log('Componente App montado, vista actual:', view);
      }, [view]);

      if (!user) {
        if (view === 'login') {
          return <Login setUser={setUser} setView={setView} error={error} setError={setError} />;
        } else if (view === 'register') {
          return <Register setView={setView} error={error} setError={setError} />;
        } else if (view === 'recover') {
          return <RecoverPassword setView={setView} />;
        }
      }

      return <Dashboard user={user} setUser={setUser} setError={setError} />;
    }

    // Componente de Login
    function Login({ setUser, setView, error, setError }) {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');

      const handleLogin = async (e) => {
        e.preventDefault();
        console.log('Intentando iniciar sesión con:', email);
        try {
          const user = await db.users.where({ email, password }).first();
          if (user) {
            localStorage.setItem('userId', user.id);
            updateLastActivity();
            setUser(user);
            setError('');
            console.log('Inicio de sesión exitoso:', user);
          } else {
            setError('Correo o contraseña incorrectos');
            console.log('Credenciales inválidas');
          }
        } catch (err) {
          setError('Error al iniciar sesión: ' + err.message);
          console.error('Error en login:', err);
        }
      };

      return (
        <div class="card" style={{ maxWidth: '400px', margin: '40px auto' }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Iniciar Sesión</h2>
          {error && <p class="error">{error}</p>}
          <form onSubmit={handleLogin} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
            <div class="form-group">
              <label>Correo</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Contraseña</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </div>
            <button type="submit" class="button button-blue">Iniciar Sesión</button>
          </form>
          <p style={{ marginTop: '20px', textAlign: 'center' }}>
            <a href="#" onClick={() => setView('register')} style={{ color: '#007bff' }}>Registrarse</a> | 
            <a href="#" onClick={() => setView('recover')} style={{ color: '#007bff' }}>¿Olvidaste tu contraseña?</a>
          </p>
        </div>
      );
    }

    // Componente de Registro
    function Register({ setView, error, setError }) {
      const [name, setName] = useState('');
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');

      const handleRegister = async (e) => {
        e.preventDefault();
        console.log('Intentando registrar usuario:', email);
        try {
          const existingUser = await db.users.where({ email }).first();
          if (existingUser) {
            setError('El correo ya está registrado');
            console.log('Correo ya registrado:', email);
            return;
          }
          const userId = generateId();
          await db.users.add({
            id: userId,
            name,
            email,
            password
          });
          setView('login');
          setError('');
          console.log('Usuario registrado exitosamente:', userId);
        } catch (err) {
          setError('Error al registrarse: ' + err.message);
          console.error('Error en registro:', err);
        }
      };

      return (
        <div class="card" style={{ maxWidth: '400px', margin: '40px auto' }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Registrarse</h2>
          {error && <p class="error">{error}</p>}
          <form onSubmit={handleRegister} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
            <div class="form-group">
              <label>Nombre</label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Correo</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Contraseña</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </div>
            <button type="submit" class="button button-blue">Registrarse</button>
          </form>
          <p style={{ marginTop: '20px', textAlign: 'center' }}>
            <a href="#" onClick={() => setView('login')} style={{ color: '#007bff' }}>Volver al inicio de sesión</a>
          </p>
        </div>
      );
    }

    // Componente de Recuperación de Contraseña
    function RecoverPassword({ setView }) {
      const [email, setEmail] = useState('');
      const [message, setMessage] = useState('');

      const handleRecover = async (e) => {
        e.preventDefault();
        console.log('Intentando recuperar contraseña para:', email);
        try {
          const user = await db.users.where({ email }).first();
          if (user) {
            setMessage('Se ha simulado el envío de un enlace de recuperación a tu correo.');
            console.log('Recuperación simulada para:', email);
          } else {
            setMessage('Correo no encontrado.');
            console.log('Correo no encontrado:', email);
          }
        } catch (err) {
          setMessage('Error: ' + err.message);
          console.error('Error en recuperación:', err);
        }
      };

      return (
        <div class="card" style={{ maxWidth: '400px', margin: '40px auto' }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Recuperar Contraseña</h2>
          {message && <p class={message.includes('Error') ? 'error' : 'success'}>{message}</p>}
          <form onSubmit={handleRecover} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
            <div class="form-group">
              <label>Correo</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <button type="submit" class="button button-blue">Enviar enlace de recuperación</button>
          </form>
          <p style={{ marginTop: '20px', textAlign: 'center' }}>
            <a href="#" onClick={() => setView('login')} style={{ color: '#007bff' }}>Volver al inicio de sesión</a>
          </p>
        </div>
      );
    }

    // Componente de Configuración
    function SettingsModal({ user, setUser, setError, onClose }) {
      const [name, setName] = useState(user.name);
      const [email, setEmail] = useState(user.email);
      const [password, setPassword] = useState(user.password);
      const [formError, setFormError] = useState('');
      const [successMessage, setSuccessMessage] = useState('');

      const handleUpdateUser = async (e) => {
        e.preventDefault();
        console.log('Intentando actualizar datos del usuario:', user.id);
        try {
          if (!name || !email || !password) {
            setFormError('Todos los campos son obligatorios.');
            console.log('Error: Campos requeridos');
            return;
          }

          const existingUser = await db.users.where({ email }).first();
          if (existingUser && existingUser.id !== user.id) {
            setFormError('El correo ya está registrado por otro usuario.');
            console.log('Correo ya registrado:', email);
            return;
          }

          await db.users.update(user.id, { name, email, password });
          const updatedUser = await db.users.get(user.id);
          setUser(updatedUser);
          setFormError('');
          setSuccessMessage('Datos actualizados exitosamente.');
          updateLastActivity();
          console.log('Datos del usuario actualizados:', updatedUser);
        } catch (err) {
          setError('Error al actualizar datos del usuario: ' + err.message);
          console.error('Error al actualizar datos del usuario:', err);
        }
      };

      const exportToCSV = async () => {
        console.log('Exportando datos a CSV...');
        try {
          const users = await db.users.toArray();
          const media = await db.media.toArray();
          const seasons = await db.seasons.toArray();
          const episodes = await db.episodes.toArray();
          const platforms = await db.platforms.toArray();

          const exportData = (data, filename) => {
            const csv = Papa.unparse(data);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            console.log(`Archivo ${filename} exportado`);
          };

          exportData(users, 'users.csv');
          exportData(media, 'media.csv');
          exportData(seasons, 'seasons.csv');
          exportData(episodes, 'episodes.csv');
          exportData(platforms, 'platforms.csv');
          updateLastActivity();
        } catch (err) {
          setError('Error al exportar CSV: ' + err.message);
          console.error('Error al exportar CSV:', err);
        }
      };

      const exportToSQL = async () => {
        console.log('Exportando datos a SQL...');
        try {
          const users = await db.users.toArray();
          const media = await db.media.toArray();
          const seasons = await db.seasons.toArray();
          const episodes = await db.episodes.toArray();
          const platforms = await db.platforms.toArray();

          let sql = `
CREATE TABLE users (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE,
  password VARCHAR(255)
);

CREATE TABLE platforms (
  name VARCHAR(50) PRIMARY KEY
);

CREATE TABLE media (
  id VARCHAR(36) PRIMARY KEY,
  userId VARCHAR(36),
  title VARCHAR(255),
  type ENUM('película', 'serie'),
  platform VARCHAR(50),
  genre VARCHAR(50),
  duration INT,
  status ENUM('visto', 'viendo', 'por ver'),
  rating INT,
  FOREIGN KEY (userId) REFERENCES users(id),
  FOREIGN KEY (platform) REFERENCES platforms(name)
);

CREATE TABLE seasons (
  id VARCHAR(36) PRIMARY KEY,
  mediaId VARCHAR(36),
  seasonNumber INT,
  episodeCount INT,
  totalDuration INT,
  FOREIGN KEY (mediaId) REFERENCES media(id)
);

CREATE TABLE episodes (
  id VARCHAR(36) PRIMARY KEY,
  seasonId VARCHAR(36),
  episodeNumber INT,
  duration INT,
  watched BOOLEAN,
  FOREIGN KEY (seasonId) REFERENCES seasons(id)
);

`;

          const escapeSQL = (value) => {
            if (value === null || value === undefined) return 'NULL';
            return `'${String(value).replace(/'/g, "''")}'`;
          };

          sql += platforms.map(p => `
INSERT INTO platforms (name)
VALUES (${escapeSQL(p.name)});
`).join('');

          sql += users.map(u => `
INSERT INTO users (id, name, email, password)
VALUES (${escapeSQL(u.id)}, ${escapeSQL(u.name)}, ${escapeSQL(u.email)}, ${escapeSQL(u.password)});
`).join('');

          sql += media.map(m => `
INSERT INTO media (id, userId, title, type, platform, genre, duration, status, rating)
VALUES (${escapeSQL(m.id)}, ${escapeSQL(m.userId)}, ${escapeSQL(m.title)}, ${escapeSQL(m.type)}, ${escapeSQL(m.platform)}, ${escapeSQL(m.genre)}, ${m.duration}, ${escapeSQL(m.status)}, ${m.rating || 'NULL'});
`).join('');

          sql += seasons.map(s => `
INSERT INTO seasons (id, mediaId, seasonNumber, episodeCount, totalDuration)
VALUES (${escapeSQL(s.id)}, ${escapeSQL(s.mediaId)}, ${s.seasonNumber}, ${s.episodeCount}, ${s.totalDuration});
`).join('');

          sql += episodes.map(e => `
INSERT INTO episodes (id, seasonId, episodeNumber, duration, watched)
VALUES (${escapeSQL(e.id)}, ${escapeSQL(e.seasonId)}, ${e.episodeNumber}, ${e.duration}, ${e.watched ? 1 : 0});
`).join('');

          const blob = new Blob([sql], { type: 'text/sql;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'database.sql';
          link.click();
          console.log('Archivo database.sql exportado');
          updateLastActivity();
        } catch (err) {
          setError('Error al exportar SQL: ' + err.message);
          console.error('Error al exportar SQL:', err);
        }
      };

      return (
        <div class="modal">
          <div class="modal-content">
            <button class="close-button" onClick={onClose}>✕</button>
            <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Configuración</h2>

            <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold', marginBottom: '15px' }}>Editar Datos del Usuario</h3>
            {formError && <p class="error">{formError}</p>}
            {successMessage && <p class="success">{successMessage}</p>}
            <form onSubmit={handleUpdateUser} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
              <div class="form-group">
                <label>Nombre</label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  required
                />
              </div>
              <div class="form-group">
                <label>Correo</label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                />
              </div>
              <div class="form-group">
                <label>Contraseña</label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                />
              </div>
              <button type="submit" class="button button-blue">Guardar Cambios</button>
            </form>

            <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold', margin: '20px 0 15px' }}>Exportar Datos</h3>
            <div class="flex">
              <button onClick={exportToCSV} class="button button-green">Exportar a CSV</button>
              <button onClick={exportToSQL} class="button button-green" style={{ marginLeft: '10px' }}>Exportar a MySQL</button>
            </div>
          </div>
        </div>
      );
    }

    // Componente del Dashboard
    function Dashboard({ user, setUser, setError }) {
      const [media, setMedia] = useState([]);
      const [filters, setFilters] = useState({
        platform: '',
        type: '',
        genre: '',
        status: ''
      });
      const [showAddForm, setShowAddForm] = useState(false);
      const [editingMedia, setEditingMedia] = useState(null);
      const [showSettings, setShowSettings] = useState(false);

      useEffect(() => {
        const fetchMedia = async () => {
          console.log('Cargando medios para usuario:', user.id);
          try {
            const userMedia = await db.media.where({ userId: user.id }).toArray();
            setMedia(userMedia);
            console.log('Medios cargados:', userMedia);
          } catch (err) {
            setError('Error al cargar medios: ' + err.message);
            console.error('Error al cargar medios:', err);
          }
        };
        fetchMedia();
      }, [user]);

      useEffect(() => {
        console.log('Estado del Dashboard - showAddForm:', showAddForm, 'editingMedia:', editingMedia);
      }, [showAddForm, editingMedia]);

      const handleLogout = () => {
        console.log('Cerrando sesión para usuario:', user.id);
        localStorage.removeItem('userId');
        localStorage.removeItem('lastActivity');
        setUser(null);
      };

      // Verificar expiración de sesión antes de realizar acciones
      const checkSessionBeforeAction = (action) => {
        if (hasSessionExpired()) {
          console.log('Sesión expirada al intentar realizar acción');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setUser(null);
          setError('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
        } else {
          action();
        }
      };

      return (
        <div class="container">
          <div class="flex" style={{ justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
            <h1 style={{ fontSize: '2rem', fontWeight: 'bold' }}>Media Tracker - {user.name}</h1>
            <div class="flex">
              <button onClick={() => checkSessionBeforeAction(() => setShowSettings(true))} class="button button-gray">Configuración</button>
              <button onClick={() => checkSessionBeforeAction(handleLogout)} class="button button-red" style={{ marginLeft: '10px' }}>Cerrar Sesión</button>
            </div>
          </div>

          {showSettings && (
            <SettingsModal
              user={user}
              setUser={setUser}
              setError={setError}
              onClose={() => setShowSettings(false)}
            />
          )}

          <button
            onClick={() => checkSessionBeforeAction(() => {
              setShowAddForm(!showAddForm);
              setEditingMedia(null);
              console.log('Botón Agregar/Cerrar clickeado - showAddForm:', !showAddForm, 'editingMedia:', null);
            })}
            class="button button-blue"
            style={{ marginBottom: '20px' }}
          >
            {showAddForm ? 'Cerrar Formulario' : 'Agregar Película/Serie'}
          </button>

          {(showAddForm || editingMedia) && (
            <MediaForm
              user={user}
              setMedia={setMedia}
              setError={setError}
              editingMedia={editingMedia}
              setEditingMedia={setEditingMedia}
              setShowAddForm={setShowAddForm}
            />
          )}

          <Filters filters={filters} setFilters={setFilters} media={media} />

          <MediaList
            media={media}
            filters={filters}
            setMedia={setMedia}
            setError={setError}
            setEditingMedia={setEditingMedia}
            setShowAddForm={setShowAddForm}
          />
        </div>
      );
    }

    // Componente para agregar/editar películas/series
    function MediaForm({ user, setMedia, setError, editingMedia, setEditingMedia, setShowAddForm }) {
      const isEditing = !!editingMedia;
      const [title, setTitle] = useState(isEditing ? editingMedia.title : '');
      const [type, setType] = useState(isEditing ? editingMedia.type : 'película');
      const [platform, setPlatform] = useState(isEditing ? editingMedia.platform : '');
      const [genre, setGenre] = useState(isEditing ? editingMedia.genre : '');
      const [duration, setDuration] = useState(isEditing ? editingMedia.duration : '');
      const [status, setStatus] = useState(isEditing ? editingMedia.status : 'por ver');
      const [rating, setRating] = useState(isEditing ? editingMedia.rating || '' : '');
      const [seasons, setSeasons] = useState([]);
      const [customGenre, setCustomGenre] = useState('');
      const [formError, setFormError] = useState('');
      const [availablePlatforms, setAvailablePlatforms] = useState([]);

      useEffect(() => {
        const fetchPlatforms = async () => {
          try {
            const platforms = await db.platforms.orderBy('name').toArray();
            setAvailablePlatforms(platforms.map(p => p.name));
            console.log('Plataformas cargadas para el formulario:', platforms.map(p => p.name));
          } catch (err) {
            setError('Error al cargar plataformas: ' + err.message);
            console.error('Error al cargar plataformas:', err);
          }
        };
        fetchPlatforms();
      }, []);

      useEffect(() => {
        if (isEditing && type === 'serie') {
          const loadSeasons = async () => {
            try {
              const mediaSeasons = await db.seasons.where({ mediaId: editingMedia.id }).toArray();
              const seasonsWithEpisodes = await Promise.all(
                mediaSeasons.map(async s => {
                  const episodes = await db.episodes.where({ seasonId: s.id }).toArray();
                  return {
                    id: s.id,
                    seasonNumber: s.seasonNumber,
                    episodeCount: s.episodeCount,
                    episodes: episodes.map(e => ({
                      id: e.id,
                      episodeNumber: e.episodeNumber,
                      duration: e.duration,
                      watched: e.watched
                    }))
                  };
                })
              );
              setSeasons(seasonsWithEpisodes);
              console.log('Temporadas cargadas para edición:', seasonsWithEpisodes);
            } catch (err) {
              setError('Error al cargar temporadas para edición: ' + err.message);
              console.error('Error al cargar temporadas:', err);
            }
          };
          loadSeasons();
        } else {
          setSeasons([]);
        }
      }, [editingMedia, type]);

      const handleAddSeason = () => {
        setSeasons([...seasons, { seasonNumber: seasons.length + 1, episodeCount: 1, episodes: [{ episodeNumber: 1, duration: 0, watched: false }] }]);
        console.log('Temporada añadida, total:', seasons.length + 1);
      };

      const handleSeasonChange = (index, field, value) => {
        const newSeasons = [...seasons];
        newSeasons[index][field] = value;
        if (field === 'episodeCount') {
          newSeasons[index].episodes = Array.from({ length: value }, (_, i) => {
            const existingEpisode = newSeasons[index].episodes[i];
            return existingEpisode || { episodeNumber: i + 1, duration: 0, watched: false };
          });
        }
        setSeasons(newSeasons);
        console.log('Temporada actualizada:', newSeasons[index]);
      };

      const handleEpisodeChange = (seasonIndex, episodeIndex, field, value) => {
        const newSeasons = [...seasons];
        newSeasons[seasonIndex].episodes[episodeIndex][field] = field === 'duration' ? parseInt(value) || 0 : value;
        setSeasons(newSeasons);
        console.log('Episodio actualizado:', newSeasons[seasonIndex].episodes[episodeIndex]);
      };

      const handleDelete = async () => {
        if (!isEditing) return;

        const confirmDelete = window.confirm(`¿Estás seguro de que deseas eliminar "${editingMedia.title}"? Esta acción no se puede deshacer.`);
        if (!confirmDelete) {
          console.log('Eliminación cancelada por el usuario');
          return;
        }

        console.log('Eliminando medio:', editingMedia.id);
        try {
          if (editingMedia.type === 'serie') {
            const mediaSeasons = await db.seasons.where({ mediaId: editingMedia.id }).toArray();
            for (const season of mediaSeasons) {
              await db.episodes.where({ seasonId: season.id }).delete();
              await db.seasons.delete(season.id);
            }
          }
          await db.media.delete(editingMedia.id);
          const userMedia = await db.media.where({ userId: user.id }).toArray();
          setMedia(userMedia);
          setEditingMedia(null);
          setShowAddForm(false);
          setFormError('');
          console.log('Medio eliminado, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al eliminar medio: ' + err.message);
          console.error('Error al eliminar medio:', err);
        }
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        console.log(isEditing ? 'Editando medio:' : 'Agregando medio:', title);
        console.log('Plataforma ingresada:', platform);

        if (hasSessionExpired()) {
          console.log('Sesión expirada al intentar guardar medio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
          return;
        }

        if (status === 'visto' && !rating) {
          setFormError('El rating es obligatorio cuando el estado es "visto".');
          console.log('Error: Rating requerido para estado "visto"');
          return;
        }

        if (!platform) {
          setFormError('El campo Plataforma es obligatorio.');
          console.log('Error: Plataforma requerida');
          return;
        }

        try {
          const trimmedPlatform = platform.trim();
          const platformExists = await db.platforms.where({ name: trimmedPlatform }).first();
          if (!platformExists) {
            await db.platforms.add({ name: trimmedPlatform });
            console.log('Nueva plataforma añadida:', trimmedPlatform);
            setAvailablePlatforms([...availablePlatforms, trimmedPlatform].sort());
          }

          const finalGenre = genre === 'Otro' ? customGenre : genre;
          const mediaId = isEditing ? editingMedia.id : generateId();

          if (isEditing) {
            console.log('Actualizando medio en IndexedDB:', { id: mediaId, platform });
            await db.media.update(mediaId, {
              title,
              type,
              platform: trimmedPlatform,
              genre: finalGenre,
              duration: parseInt(duration) || 0,
              status,
              rating: rating ? parseInt(rating) : null
            });

            if (type === 'serie') {
              const existingSeasons = await db.seasons.where({ mediaId }).toArray();
              for (const season of existingSeasons) {
                await db.episodes.where({ seasonId: season.id }).delete();
                await db.seasons.delete(season.id);
              }

              for (const season of seasons) {
                const seasonId = season.id || generateId();
                const totalDuration = season.episodes.reduce((sum, ep) => sum + (ep.duration || 0), 0);
                await db.seasons.add({
                  id: seasonId,
                  mediaId,
                  seasonNumber: season.seasonNumber,
                  episodeCount: season.episodeCount,
                  totalDuration
                });

                for (const episode of season.episodes) {
                  const episodeId = episode.id || generateId();
                  await db.episodes.add({
                    id: episodeId,
                    seasonId,
                    episodeNumber: episode.episodeNumber,
                    duration: episode.duration || 0,
                    watched: episode.watched
                  });
                }
              }
            }
          } else {
            console.log('Guardando nuevo medio en IndexedDB:', { id: mediaId, platform });
            await db.media.add({
              id: mediaId,
              userId: user.id,
              title,
              type,
              platform: trimmedPlatform,
              genre: finalGenre,
              duration: parseInt(duration) || 0,
              status,
              rating: rating ? parseInt(rating) : null
            });

            if (type === 'serie') {
              for (const season of seasons) {
                const seasonId = generateId();
                const totalDuration = season.episodes.reduce((sum, ep) => sum + (ep.duration || 0), 0);
                await db.seasons.add({
                  id: seasonId,
                  mediaId,
                  seasonNumber: season.seasonNumber,
                  episodeCount: season.episodeCount,
                  totalDuration
                });

                for (const episode of season.episodes) {
                  const episodeId = generateId();
                  await db.episodes.add({
                    id: episodeId,
                    seasonId,
                    episodeNumber: episode.episodeNumber,
                    duration: episode.duration || 0,
                    watched: episode.watched
                  });
                }
              }
            }
          }

          const userMedia = await db.media.where({ userId: user.id }).toArray();
          console.log('Medios recargados después de guardar:', userMedia);
          setMedia(userMedia);

          setTitle('');
          setType('película');
          setPlatform('');
          setGenre('');
          setDuration('');
          setStatus('por ver');
          setRating('');
          setSeasons([]);
          setCustomGenre('');
          setEditingMedia(null);
          setShowAddForm(false);
          setFormError('');
          console.log(isEditing ? 'Medio actualizado:' : 'Medio añadido:', { id: mediaId, title, platform });
          updateLastActivity();
        } catch (err) {
          setError((isEditing ? 'Error al editar medio: ' : 'Error al agregar medio: ') + err.message);
          console.error('Error:', err);
        }
      };

      return (
        <form onSubmit={handleSubmit} class="card">
          <h2 style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '20px' }}>
            {isEditing ? 'Editar Película/Serie' : 'Agregar Película/Serie'}
          </h2>
          {formError && <p class="error">{formError}</p>}
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
            <div class="form-group">
              <label>Título</label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Tipo</label>
              <select value={type} onChange={(e) => setType(e.target.value)}>
                <option value="película">Película</option>
                <option value="serie">Serie</option>
              </select>
            </div>
            <div class="form-group">
              <label>Plataforma</label>
              <input
                type="text"
                list="platform-suggestions"
                value={platform}
                onChange={(e) => setPlatform(e.target.value)}
                required
              />
              <datalist id="platform-suggestions">
                {availablePlatforms.map(p => <option key={p} value={p} />)}
              </datalist>
            </div>
            <div class="form-group">
              <label>Género</label>
              <select value={genre} onChange={(e) => setGenre(e.target.value)}>
                <option value="">Selecciona Género</option>
                {genres.map(g => <option key={g} value={g}>{g}</option>)}
              </select>
              {genre === 'Otro' && (
                <input
                  type="text"
                  placeholder="Género personalizado"
                  value={customGenre}
                  onChange={(e) => setCustomGenre(e.target.value)}
                  style={{ marginTop: '10px' }}
                  required
                />
              )}
            </div>
            <div class="form-group">
              <label>Duración (minutos)</label>
              <input
                type="number"
                value={duration}
                onChange={(e) => setDuration(e.target.value)}
                required={type === 'película'}
              />
            </div>
            <div class="form-group">
              <label>Estado</label>
              <select value={status} onChange={(e) => setStatus(e.target.value)}>
                <option value="visto">Visto</option>
                <option value="viendo">Viendo</option>
                <option value="por ver">Por Ver</option>
              </select>
            </div>
            <div class="form-group">
              <label>Rating (1-5)</label>
              <select
                value={rating}
                onChange={(e) => setRating(e.target.value)}
                required={status === 'visto'}
              >
                <option value="">Sin calificar</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
          </div>

          {type === 'serie' && (
            <div style={{ marginTop: '20px' }}>
              <h3 style={{ fontSize: '1.1rem', fontWeight: 'bold' }}>Temporadas</h3>
              <button
                type="button"
                onClick={handleAddSeason}
                class="button button-blue"
                style={{ margin: '10px 0' }}
              >
                Agregar Temporada
              </button>
              {seasons.map((season, sIndex) => (
                <div key={sIndex} class="card" style={{ marginTop: '10px', background: '#f9f9f9' }}>
                  <h4 style={{ fontWeight: 'bold' }}>Temporada {season.seasonNumber}</h4>
                  <div class="form-group">
                    <label>Número de episodios</label>
                    <input
                      type="number"
                      value={season.episodeCount}
                      onChange={(e) => handleSeasonChange(sIndex, 'episodeCount', parseInt(e.target.value))}
                      min="1"
                      required
                    />
                  </div>
                  {season.episodes.map((episode, eIndex) => (
                    <div key={eIndex} class="flex" style={{ marginTop: '10px' }}>
                      <span style={{ flex: '1' }}>Episodio {episode.episodeNumber}</span>
                      <input
                        type="number"
                        placeholder="Duración (min)"
                        value={episode.duration}
                        onChange={(e) => handleEpisodeChange(sIndex, eIndex, 'duration', e.target.value)}
                        style={{ width: '100px' }}
                        min="0"
                      />
                      <label>
                        <input
                          type="checkbox"
                          checked={episode.watched}
                          onChange={(e) => handleEpisodeChange(sIndex, eIndex, 'watched', e.target.checked)}
                        />
                        Visto
                      </label>
                    </div>
                  ))}
                </div>
              ))}
            </div>
          )}

          <div class="flex" style={{ marginTop: '20px', gap: '10px' }}>
            <button type="submit" class="button button-blue">
              {isEditing ? 'Guardar Cambios' : 'Agregar'}
            </button>
            {isEditing && (
              <button
                type="button"
                onClick={handleDelete}
                class="button button-red"
              >
                Eliminar
              </button>
            )}
            <button
              type="button"
              onClick={() => {
                setEditingMedia(null);
                setShowAddForm(false);
                setFormError('');
                console.log('Formulario cerrado - showAddForm:', false, 'editingMedia:', null);
                updateLastActivity();
              }}
              class="button button-gray"
            >
              Cancelar
            </button>
          </div>
        </form>
      );
    }

    // Componente de Filtros
    function Filters({ filters, setFilters, media }) {
      const [availablePlatforms, setAvailablePlatforms] = useState([]);

      useEffect(() => {
        const fetchPlatforms = async () => {
          try {
            const platforms = await db.platforms.orderBy('name').toArray();
            const platformNames = platforms.map(p => p.name);
            console.log('Plataformas disponibles para filtros:', platformNames);
            setAvailablePlatforms(platformNames);
          } catch (err) {
            console.error('Error al cargar plataformas para filtros:', err);
          }
        };
        fetchPlatforms();
      }, []);

      return (
        <div class="card">
          <h2 style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '20px' }}>Filtros</h2>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px' }}>
            <div class="form-group">
              <label>Plataforma</label>
              <select
                value={filters.platform}
                onChange={(e) => setFilters({ ...filters, platform: e.target.value })}
              >
                <option value="">Todas las Plataformas</option>
                {availablePlatforms.map(p => <option key={p} value={p}>{p}</option>)}
              </select>
            </div>
            <div class="form-group">
              <label>Tipo</label>
              <select
                value={filters.type}
                onChange={(e) => setFilters({ ...filters, type: e.target.value })}
              >
                <option value="">Películas y Series</option>
                <option value="película">Película</option>
                <option value="serie">Serie</option>
              </select>
            </div>
            <div class="form-group">
              <label>Género</label>
              <select
                value={filters.genre}
                onChange={(e) => setFilters({ ...filters, genre: e.target.value })}
              >
                <option value="">Todos los Géneros</option>
                {genres.map(g => <option key={g} value={g}>{g}</option>)}
              </select>
            </div>
            <div class="form-group">
              <label>Estado</label>
              <select
                value={filters.status}
                onChange={(e) => setFilters({ ...filters, status: e.target.value })}
              >
                <option value="">Todos los Estados</option>
                <option value="visto">Visto</option>
                <option value="viendo">Viendo</option>
                <option value="por ver">Por Ver</option>
              </select>
            </div>
          </div>
        </div>
      );
    }

    // Componente de Lista de Medios
    function MediaList({ media, filters, setMedia, setError, setEditingMedia, setShowAddForm }) {
      const [mediaWithTime, setMediaWithTime] = useState([]);

      useEffect(() => {
        const calculateWatchedTime = async () => {
          console.log('Calculando tiempo visto para medios:', media);
          try {
            const updatedMedia = await Promise.all(media.map(async m => {
              const totalTime = await getTotalWatchedTime(m.id, m.type);
              return { ...m, totalWatchedTime: totalTime };
            }));
            setMediaWithTime(updatedMedia);
            console.log('Medios con tiempo calculado:', updatedMedia);
          } catch (err) {
            setError('Error al calcular tiempo visto: ' + err.message);
            console.error('Error al calcular tiempo visto:', err);
          }
        };
        calculateWatchedTime();
      }, [media]);

      const filteredMedia = mediaWithTime.filter(m => {
        return (
          (!filters.platform || m.platform === filters.platform) &&
          (!filters.type || m.type === filters.type) &&
          (!filters.genre || m.genre === filters.genre) &&
          (!filters.status || m.status === filters.status)
        );
      });

      const handleStatusChange = async (mediaId, newStatus) => {
        console.log('Actualizando estado del medio:', mediaId, newStatus);
        if (hasSessionExpired()) {
          console.log('Sesión expirada al intentar cambiar estado');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
          return;
        }

        try {
          const mediaItem = await db.media.get(mediaId);
          if (newStatus === 'visto' && !mediaItem.rating) {
            setError('Debes seleccionar un rating antes de marcar este medio como "visto".');
            console.log('Error: Rating requerido para estado "visto"');
            return;
          }
          await db.media.update(mediaId, { status: newStatus });
          const userMedia = await db.media.where({ userId: media[0].userId }).toArray();
          setMedia(userMedia);
          console.log('Estado actualizado, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al actualizar estado: ' + err.message);
          console.error('Error al actualizar estado:', err);
        }
      };

      const handleEpisodeToggle = async (episodeId, watched) => {
        console.log('Actualizando episodio:', episodeId, watched);
        if (hasSessionExpired()) {
          console.log('Sesión expirada al intentar actualizar episodio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
          return;
        }

        try {
          await db.episodes.update(episodeId, { watched });
          const userMedia = await db.media.where({ userId: media[0].userId }).toArray();
          setMedia(userMedia);
          console.log('Episodio actualizado, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al actualizar episodio: ' + err.message);
          console.error('Error al actualizar episodio:', err);
        }
      };

      const handleEdit = (mediaItem) => {
        if (hasSessionExpired()) {
          console.log('Sesión expirada al intentar editar medio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesión ha expirada. Por favor, inicia sesión nuevamente.');
          return;
        }

        setEditingMedia(mediaItem);
        setShowAddForm(false);
        console.log('Editando medio:', mediaItem.id, 'showAddForm:', false, 'editingMedia:', mediaItem);
        window.scrollTo({ top: 0, behavior: 'smooth' });
        updateLastActivity();
      };

      const handleDelete = async (mediaItem) => {
        if (hasSessionExpired()) {
          console.log('Sesión expirada al intentar eliminar medio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
          return;
        }

        const confirmDelete = window.confirm(`¿Estás seguro de que deseas eliminar "${mediaItem.title}"? Esta acción no se puede deshacer.`);
        if (!confirmDelete) {
          console.log('Eliminación cancelada por el usuario');
          return;
        }

        console.log('Eliminando medio desde lista:', mediaItem.id);
        try {
          if (mediaItem.type === 'serie') {
            const mediaSeasons = await db.seasons.where({ mediaId: mediaItem.id }).toArray();
            for (const season of mediaSeasons) {
              await db.episodes.where({ seasonId: season.id }).delete();
              await db.seasons.delete(season.id);
            }
          }
          await db.media.delete(mediaItem.id);
          const userMedia = await db.media.where({ userId: media[0].userId }).toArray();
          setMedia(userMedia);
          console.log('Medio eliminado desde lista, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al eliminar medio desde lista: ' + err.message);
          console.error('Error al eliminar medio desde lista:', err);
        }
      };

      const getTotalWatchedTime = async (mediaId, type) => {
        try {
          if (type === 'película') {
            const m = await db.media.get(mediaId);
            return m.status === 'visto' ? m.duration : 0;
          } else {
            const seasons = await db.seasons.where({ mediaId }).toArray();
            let total = 0;
            for (const season of seasons) {
              const episodes = await db.episodes.where({ seasonId: season.id }).toArray();
              total += episodes.reduce((sum, ep) => sum + (ep.watched ? ep.duration : 0), 0);
            }
            return total;
          }
        } catch (err) {
          console.error('Error al calcular tiempo visto para medio:', mediaId, err);
          return 0;
        }
      };

      return (
        <div class="grid">
          {filteredMedia.length > 0 ? filteredMedia.map(m => (
            <div key={m.id} class="card">
              <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>{m.title}</h3>
              <p>Tipo: {m.type}</p>
              <p class="platform-highlight">Plataforma: {m.platform}</p>
              <p>Género: {m.genre}</p>
              <p>Duración: {m.duration} min</p>
              <p>Tiempo Visto: {m.totalWatchedTime} min</p>
              <p>Rating: {m.rating ? m.rating + '/5' : 'Sin calificar'}</p>
              <div class="form-group">
                <label>Estado</label>
                <select
                  value={m.status}
                  onChange={(e) => handleStatusChange(m.id, e.target.value)}
                >
                  <option value="visto">Visto</option>
                  <option value="viendo">Viendo</option>
                  <option value="por ver">Por Ver</option>
                </select>
              </div>
              <div class="flex" style={{ marginTop: '10px' }}>
                <button
                  onClick={() => handleEdit(m)}
                  class="button button-blue"
                >
                  Editar
                </button>
                <button
                  onClick={() => handleDelete(m)}
                  class="button button-red"
                >
                  Eliminar
                </button>
              </div>
              {m.type === 'serie' && (
                <SeriesDetails mediaId={m.id} handleEpisodeToggle={handleEpisodeToggle} />
              )}
            </div>
          )) : (
            <p style={{ color: '#666' }}>No hay medios que coincidan con los filtros.</p>
          )}
        </div>
      );
    }

    // Componente de Detalles de Series
    function SeriesDetails({ mediaId, handleEpisodeToggle }) {
      const [seasons, setSeasons] = useState([]);

      useEffect(() => {
        const fetchSeasons = async () => {
          console.log('Cargando temporadas para medio:', mediaId);
          try {
            const seasons = await db.seasons.where({ mediaId }).toArray();
            const seasonsWithEpisodes = await Promise.all(
              seasons.map(async s => {
                const episodes = await db.episodes.where({ seasonId: s.id }).toArray();
                return { ...s, episodes, completed: episodes.every(e => e.watched) };
              })
            );
            setSeasons(seasonsWithEpisodes);
            console.log('Temporadas cargadas:', seasonsWithEpisodes);
          } catch (err) {
            console.error('Error al cargar temporadas:', err);
          }
        };
        fetchSeasons();
      }, [mediaId]);

      return (
        <div style={{ marginTop: '20px' }}>
          <h4 style={{ fontWeight: 'bold' }}>Temporadas</h4>
          {seasons.length > 0 ? seasons.map(s => (
            <div key={s.id} style={{ marginTop: '10px' }}>
              <p>Temporada {s.seasonNumber} {s.completed ? '(Completada)' : ''}</p>
              {s.episodes.map(e => (
                <div key={e.id} class="flex" style={{ marginTop: '5px' }}>
                  <input
                    type="checkbox"
                    checked={e.watched}
                    onChange={() => handleEpisodeToggle(e.id, !e.watched)}
                  />
                  <span>Episodio {e.episodeNumber} ({e.duration} min)</span>
                </div>
              ))}
            </div>
          )) : (
            <p style={{ color: '#666' }}>No hay temporadas registradas.</p>
          )}
        </div>
      );
    }

    // Renderizar la aplicación
    try {
      console.log('Renderizando aplicación...');
      ReactDOM.render(<App />, document.getElementById('root'));
      console.log('Aplicación renderizada exitosamente');
    } catch (err) {
      console.error('Error al renderizar la aplicación:', err);
      document.getElementById('root').innerHTML = '<p class="error" style="padding: 20px;">Error al cargar la aplicación. Por favor, revisa la consola del navegador para más detalles.</p>';
    }
  </script>
</body>
</html>
