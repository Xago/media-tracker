<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Tracker (Versi√≥n 8.0)</title>
  <style>
    body {
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .form-group {
      margin-bottom: 15px;
    }
    .form-group label {
      display: block;
      margin-bottom: 5px;
    }
    .form-group input, .form-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: white;
    }
    .button-blue { background-color: #007bff; }
    .button-blue:hover { background-color: #0056b3; }
    .button-green { background-color: #28a745; }
    .button-green:hover { background-color: #218838; }
    .button-red { background-color: #dc3545; }
    .button-red:hover { background-color: #c82333; }
    .button-gray { background-color: #6c757d; }
    .button-gray:hover { background-color: #5a6268; }
    .error { color: red; }
    .success { color: green; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .flex { display: flex; gap: 10px; align-items: center; }
    .platform-highlight { color: red; }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 500px;
      width: 100%;
      position: relative;
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="libs/react.min.js"></script>
  <script src="libs/react-dom.min.js"></script>
  <script src="libs/babel.min.js"></script>
  <script src="libs/dexie.min.js"></script>
  <script src="libs/papaparse.min.js"></script>
  <script type="text/babel">
    const { useState, useEffect } = React;

    console.log('Iniciando aplicaci√≥n...');
    console.log('üí° Consejo: Para detectar cambios en el c√≥digo autom√°ticamente y recargar el navegador sin cerrar sesi√≥n, usa "live-server" en lugar de "http-server". Inst√°lalo con "npm install -g live-server", luego ejecuta "live-server" en la carpeta "media-tracker". Esto recargar√° la p√°gina autom√°ticamente cuando hagas cambios en "index.html".');

    // Inicializar IndexedDB con Dexie
    let db;
    try {
      db = new Dexie('MediaTrackerDB');
      db.version(2).stores({
        users: 'id,name,email,password',
        media: 'id,userId,title,type,platform,genre,duration,status,rating',
        seasons: 'id,mediaId,seasonNumber,episodeCount,totalDuration',
        episodes: 'id,seasonId,episodeNumber,duration,watched',
        platforms: 'name'
      }).upgrade(async (trans) => {
        console.log('Ejecutando migraci√≥n de datos para la versi√≥n 2...');
        const media = await trans.table('media').toArray();
        const existingPlatforms = [...new Set(media.map(m => m.platform))].filter(p => p);
        const defaultPlatforms = ['Netflix', 'Prime', 'Disney', 'Paramount'];
        const allPlatforms = [...new Set([...defaultPlatforms, ...existingPlatforms])];
        await trans.table('platforms').bulkAdd(allPlatforms.map(name => ({ name })));
        console.log('Plataformas migradas:', allPlatforms);
      });
      console.log('IndexedDB inicializado correctamente');
    } catch (err) {
      console.error('Error al inicializar IndexedDB:', err);
    }

    // Generar ID √∫nico sin uuid
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

    // Lista de g√©neros
    const genres = [
      'Acci√≥n', 'Aventura', 'Animaci√≥n', 'Ciencia Ficci√≥n', 'Comedia', 'Crimen',
      'Documental', 'Drama', 'Fantas√≠a', 'Historia', 'Horror', 'Misterio',
      'Romance', 'Suspenso', 'Western', 'Otro'
    ];

    // Tiempo de expiraci√≥n de la sesi√≥n (en milisegundos): 30 minutos
    const SESSION_TIMEOUT = 30 * 60 * 1000;

    // Funci√≥n para actualizar la √∫ltima actividad del usuario
    const updateLastActivity = () => {
      const now = Date.now();
      localStorage.setItem('lastActivity', now.toString());
      console.log('√öltima actividad actualizada:', new Date(now).toISOString());
    };

    // Funci√≥n para verificar si la sesi√≥n ha expirado
    const hasSessionExpired = () => {
      const lastActivity = localStorage.getItem('lastActivity');
      if (!lastActivity) return true; // Si no hay √∫ltima actividad, la sesi√≥n ha expirado
      const now = Date.now();
      const timeSinceLastActivity = now - parseInt(lastActivity, 10);
      console.log('Tiempo desde la √∫ltima actividad:', timeSinceLastActivity / 1000, 'segundos');
      return timeSinceLastActivity > SESSION_TIMEOUT;
    };

    // Componente principal
    function App() {
      const [user, setUser] = useState(null);
      const [view, setView] = useState('login');
      const [error, setError] = useState('');

      // Restaurar sesi√≥n al iniciar la aplicaci√≥n
      useEffect(() => {
        const restoreSession = async () => {
          console.log('Intentando restaurar sesi√≥n...');
          const userId = localStorage.getItem('userId');
          if (userId) {
            try {
              const storedUser = await db.users.get(userId);
              if (storedUser) {
                if (hasSessionExpired()) {
                  console.log('Sesi√≥n expirada, limpiando datos...');
                  localStorage.removeItem('userId');
                  localStorage.removeItem('lastActivity');
                  setError('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.');
                } else {
                  setUser(storedUser);
                  setView('dashboard');
                  updateLastActivity();
                  console.log('Sesi√≥n restaurada para usuario:', storedUser);
                }
              } else {
                console.log('No se encontr√≥ usuario con ID:', userId);
                localStorage.removeItem('userId');
                localStorage.removeItem('lastActivity');
              }
            } catch (err) {
              console.error('Error al restaurar sesi√≥n:', err);
              localStorage.removeItem('userId');
              localStorage.removeItem('lastActivity');
            }
          } else {
            console.log('No se encontr√≥ userId en localStorage');
          }
        };
        restoreSession();
      }, []);

      // Registrar eventos de actividad del usuario (clics, teclas, etc.)
      useEffect(() => {
        const handleActivity = () => {
          if (user) { // Solo actualizar si hay un usuario logueado
            updateLastActivity();
          }
        };

        window.addEventListener('click', handleActivity);
        window.addEventListener('keydown', handleActivity);
        window.addEventListener('mousemove', handleActivity);

        return () => {
          window.removeEventListener('click', handleActivity);
          window.removeEventListener('keydown', handleActivity);
          window.removeEventListener('mousemove', handleActivity);
        };
      }, [user]);

      useEffect(() => {
        console.log('Componente App montado, vista actual:', view);
      }, [view]);

      if (!user) {
        if (view === 'login') {
          return <Login setUser={setUser} setView={setView} error={error} setError={setError} />;
        } else if (view === 'register') {
          return <Register setView={setView} error={error} setError={setError} />;
        } else if (view === 'recover') {
          return <RecoverPassword setView={setView} />;
        }
      }

      return <Dashboard user={user} setUser={setUser} setError={setError} />;
    }

    // Componente de Login
    function Login({ setUser, setView, error, setError }) {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');

      const handleLogin = async (e) => {
        e.preventDefault();
        console.log('Intentando iniciar sesi√≥n con:', email);
        try {
          const user = await db.users.where({ email, password }).first();
          if (user) {
            localStorage.setItem('userId', user.id);
            updateLastActivity();
            setUser(user);
            setError('');
            console.log('Inicio de sesi√≥n exitoso:', user);
          } else {
            setError('Correo o contrase√±a incorrectos');
            console.log('Credenciales inv√°lidas');
          }
        } catch (err) {
          setError('Error al iniciar sesi√≥n: ' + err.message);
          console.error('Error en login:', err);
        }
      };

      return (
        <div class="card" style={{ maxWidth: '400px', margin: '40px auto' }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Iniciar Sesi√≥n</h2>
          {error && <p class="error">{error}</p>}
          <form onSubmit={handleLogin} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
            <div class="form-group">
              <label>Correo</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Contrase√±a</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </div>
            <button type="submit" class="button button-blue">Iniciar Sesi√≥n</button>
          </form>
          <p style={{ marginTop: '20px', textAlign: 'center' }}>
            <a href="#" onClick={() => setView('register')} style={{ color: '#007bff' }}>Registrarse</a> | 
            <a href="#" onClick={() => setView('recover')} style={{ color: '#007bff' }}>¬øOlvidaste tu contrase√±a?</a>
          </p>
        </div>
      );
    }

    // Componente de Registro
    function Register({ setView, error, setError }) {
      const [name, setName] = useState('');
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');

      const handleRegister = async (e) => {
        e.preventDefault();
        console.log('Intentando registrar usuario:', email);
        try {
          const existingUser = await db.users.where({ email }).first();
          if (existingUser) {
            setError('El correo ya est√° registrado');
            console.log('Correo ya registrado:', email);
            return;
          }
          const userId = generateId();
          await db.users.add({
            id: userId,
            name,
            email,
            password
          });
          setView('login');
          setError('');
          console.log('Usuario registrado exitosamente:', userId);
        } catch (err) {
          setError('Error al registrarse: ' + err.message);
          console.error('Error en registro:', err);
        }
      };

      return (
        <div class="card" style={{ maxWidth: '400px', margin: '40px auto' }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Registrarse</h2>
          {error && <p class="error">{error}</p>}
          <form onSubmit={handleRegister} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
            <div class="form-group">
              <label>Nombre</label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Correo</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Contrase√±a</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </div>
            <button type="submit" class="button button-blue">Registrarse</button>
          </form>
          <p style={{ marginTop: '20px', textAlign: 'center' }}>
            <a href="#" onClick={() => setView('login')} style={{ color: '#007bff' }}>Volver al inicio de sesi√≥n</a>
          </p>
        </div>
      );
    }

    // Componente de Recuperaci√≥n de Contrase√±a
    function RecoverPassword({ setView }) {
      const [email, setEmail] = useState('');
      const [message, setMessage] = useState('');

      const handleRecover = async (e) => {
        e.preventDefault();
        console.log('Intentando recuperar contrase√±a para:', email);
        try {
          const user = await db.users.where({ email }).first();
          if (user) {
            setMessage('Se ha simulado el env√≠o de un enlace de recuperaci√≥n a tu correo.');
            console.log('Recuperaci√≥n simulada para:', email);
          } else {
            setMessage('Correo no encontrado.');
            console.log('Correo no encontrado:', email);
          }
        } catch (err) {
          setMessage('Error: ' + err.message);
          console.error('Error en recuperaci√≥n:', err);
        }
      };

      return (
        <div class="card" style={{ maxWidth: '400px', margin: '40px auto' }}>
          <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Recuperar Contrase√±a</h2>
          {message && <p class={message.includes('Error') ? 'error' : 'success'}>{message}</p>}
          <form onSubmit={handleRecover} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
            <div class="form-group">
              <label>Correo</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <button type="submit" class="button button-blue">Enviar enlace de recuperaci√≥n</button>
          </form>
          <p style={{ marginTop: '20px', textAlign: 'center' }}>
            <a href="#" onClick={() => setView('login')} style={{ color: '#007bff' }}>Volver al inicio de sesi√≥n</a>
          </p>
        </div>
      );
    }

    // Componente de Configuraci√≥n
    function SettingsModal({ user, setUser, setError, onClose }) {
      const [name, setName] = useState(user.name);
      const [email, setEmail] = useState(user.email);
      const [password, setPassword] = useState(user.password);
      const [formError, setFormError] = useState('');
      const [successMessage, setSuccessMessage] = useState('');

      const handleUpdateUser = async (e) => {
        e.preventDefault();
        console.log('Intentando actualizar datos del usuario:', user.id);
        try {
          if (!name || !email || !password) {
            setFormError('Todos los campos son obligatorios.');
            console.log('Error: Campos requeridos');
            return;
          }

          const existingUser = await db.users.where({ email }).first();
          if (existingUser && existingUser.id !== user.id) {
            setFormError('El correo ya est√° registrado por otro usuario.');
            console.log('Correo ya registrado:', email);
            return;
          }

          await db.users.update(user.id, { name, email, password });
          const updatedUser = await db.users.get(user.id);
          setUser(updatedUser);
          setFormError('');
          setSuccessMessage('Datos actualizados exitosamente.');
          updateLastActivity();
          console.log('Datos del usuario actualizados:', updatedUser);
        } catch (err) {
          setError('Error al actualizar datos del usuario: ' + err.message);
          console.error('Error al actualizar datos del usuario:', err);
        }
      };

      const exportToCSV = async () => {
        console.log('Exportando datos a CSV...');
        try {
          const users = await db.users.toArray();
          const media = await db.media.toArray();
          const seasons = await db.seasons.toArray();
          const episodes = await db.episodes.toArray();
          const platforms = await db.platforms.toArray();

          const exportData = (data, filename) => {
            const csv = Papa.unparse(data);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            console.log(`Archivo ${filename} exportado`);
          };

          exportData(users, 'users.csv');
          exportData(media, 'media.csv');
          exportData(seasons, 'seasons.csv');
          exportData(episodes, 'episodes.csv');
          exportData(platforms, 'platforms.csv');
          updateLastActivity();
        } catch (err) {
          setError('Error al exportar CSV: ' + err.message);
          console.error('Error al exportar CSV:', err);
        }
      };

      const exportToSQL = async () => {
        console.log('Exportando datos a SQL...');
        try {
          const users = await db.users.toArray();
          const media = await db.media.toArray();
          const seasons = await db.seasons.toArray();
          const episodes = await db.episodes.toArray();
          const platforms = await db.platforms.toArray();

          let sql = `
CREATE TABLE users (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE,
  password VARCHAR(255)
);

CREATE TABLE platforms (
  name VARCHAR(50) PRIMARY KEY
);

CREATE TABLE media (
  id VARCHAR(36) PRIMARY KEY,
  userId VARCHAR(36),
  title VARCHAR(255),
  type ENUM('pel√≠cula', 'serie'),
  platform VARCHAR(50),
  genre VARCHAR(50),
  duration INT,
  status ENUM('visto', 'viendo', 'por ver'),
  rating INT,
  FOREIGN KEY (userId) REFERENCES users(id),
  FOREIGN KEY (platform) REFERENCES platforms(name)
);

CREATE TABLE seasons (
  id VARCHAR(36) PRIMARY KEY,
  mediaId VARCHAR(36),
  seasonNumber INT,
  episodeCount INT,
  totalDuration INT,
  FOREIGN KEY (mediaId) REFERENCES media(id)
);

CREATE TABLE episodes (
  id VARCHAR(36) PRIMARY KEY,
  seasonId VARCHAR(36),
  episodeNumber INT,
  duration INT,
  watched BOOLEAN,
  FOREIGN KEY (seasonId) REFERENCES seasons(id)
);

`;

          const escapeSQL = (value) => {
            if (value === null || value === undefined) return 'NULL';
            return `'${String(value).replace(/'/g, "''")}'`;
          };

          sql += platforms.map(p => `
INSERT INTO platforms (name)
VALUES (${escapeSQL(p.name)});
`).join('');

          sql += users.map(u => `
INSERT INTO users (id, name, email, password)
VALUES (${escapeSQL(u.id)}, ${escapeSQL(u.name)}, ${escapeSQL(u.email)}, ${escapeSQL(u.password)});
`).join('');

          sql += media.map(m => `
INSERT INTO media (id, userId, title, type, platform, genre, duration, status, rating)
VALUES (${escapeSQL(m.id)}, ${escapeSQL(m.userId)}, ${escapeSQL(m.title)}, ${escapeSQL(m.type)}, ${escapeSQL(m.platform)}, ${escapeSQL(m.genre)}, ${m.duration}, ${escapeSQL(m.status)}, ${m.rating || 'NULL'});
`).join('');

          sql += seasons.map(s => `
INSERT INTO seasons (id, mediaId, seasonNumber, episodeCount, totalDuration)
VALUES (${escapeSQL(s.id)}, ${escapeSQL(s.mediaId)}, ${s.seasonNumber}, ${s.episodeCount}, ${s.totalDuration});
`).join('');

          sql += episodes.map(e => `
INSERT INTO episodes (id, seasonId, episodeNumber, duration, watched)
VALUES (${escapeSQL(e.id)}, ${escapeSQL(e.seasonId)}, ${e.episodeNumber}, ${e.duration}, ${e.watched ? 1 : 0});
`).join('');

          const blob = new Blob([sql], { type: 'text/sql;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'database.sql';
          link.click();
          console.log('Archivo database.sql exportado');
          updateLastActivity();
        } catch (err) {
          setError('Error al exportar SQL: ' + err.message);
          console.error('Error al exportar SQL:', err);
        }
      };

      return (
        <div class="modal">
          <div class="modal-content">
            <button class="close-button" onClick={onClose}>‚úï</button>
            <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '20px' }}>Configuraci√≥n</h2>

            <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold', marginBottom: '15px' }}>Editar Datos del Usuario</h3>
            {formError && <p class="error">{formError}</p>}
            {successMessage && <p class="success">{successMessage}</p>}
            <form onSubmit={handleUpdateUser} style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
              <div class="form-group">
                <label>Nombre</label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  required
                />
              </div>
              <div class="form-group">
                <label>Correo</label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                />
              </div>
              <div class="form-group">
                <label>Contrase√±a</label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                />
              </div>
              <button type="submit" class="button button-blue">Guardar Cambios</button>
            </form>

            <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold', margin: '20px 0 15px' }}>Exportar Datos</h3>
            <div class="flex">
              <button onClick={exportToCSV} class="button button-green">Exportar a CSV</button>
              <button onClick={exportToSQL} class="button button-green" style={{ marginLeft: '10px' }}>Exportar a MySQL</button>
            </div>
          </div>
        </div>
      );
    }

    // Componente del Dashboard
    function Dashboard({ user, setUser, setError }) {
      const [media, setMedia] = useState([]);
      const [filters, setFilters] = useState({
        platform: '',
        type: '',
        genre: '',
        status: ''
      });
      const [showAddForm, setShowAddForm] = useState(false);
      const [editingMedia, setEditingMedia] = useState(null);
      const [showSettings, setShowSettings] = useState(false);

      useEffect(() => {
        const fetchMedia = async () => {
          console.log('Cargando medios para usuario:', user.id);
          try {
            const userMedia = await db.media.where({ userId: user.id }).toArray();
            setMedia(userMedia);
            console.log('Medios cargados:', userMedia);
          } catch (err) {
            setError('Error al cargar medios: ' + err.message);
            console.error('Error al cargar medios:', err);
          }
        };
        fetchMedia();
      }, [user]);

      useEffect(() => {
        console.log('Estado del Dashboard - showAddForm:', showAddForm, 'editingMedia:', editingMedia);
      }, [showAddForm, editingMedia]);

      const handleLogout = () => {
        console.log('Cerrando sesi√≥n para usuario:', user.id);
        localStorage.removeItem('userId');
        localStorage.removeItem('lastActivity');
        setUser(null);
      };

      // Verificar expiraci√≥n de sesi√≥n antes de realizar acciones
      const checkSessionBeforeAction = (action) => {
        if (hasSessionExpired()) {
          console.log('Sesi√≥n expirada al intentar realizar acci√≥n');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setUser(null);
          setError('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.');
        } else {
          action();
        }
      };

      return (
        <div class="container">
          <div class="flex" style={{ justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
            <h1 style={{ fontSize: '2rem', fontWeight: 'bold' }}>Media Tracker - {user.name}</h1>
            <div class="flex">
              <button onClick={() => checkSessionBeforeAction(() => setShowSettings(true))} class="button button-gray">Configuraci√≥n</button>
              <button onClick={() => checkSessionBeforeAction(handleLogout)} class="button button-red" style={{ marginLeft: '10px' }}>Cerrar Sesi√≥n</button>
            </div>
          </div>

          {showSettings && (
            <SettingsModal
              user={user}
              setUser={setUser}
              setError={setError}
              onClose={() => setShowSettings(false)}
            />
          )}

          <button
            onClick={() => checkSessionBeforeAction(() => {
              setShowAddForm(!showAddForm);
              setEditingMedia(null);
              console.log('Bot√≥n Agregar/Cerrar clickeado - showAddForm:', !showAddForm, 'editingMedia:', null);
            })}
            class="button button-blue"
            style={{ marginBottom: '20px' }}
          >
            {showAddForm ? 'Cerrar Formulario' : 'Agregar Pel√≠cula/Serie'}
          </button>

          {(showAddForm || editingMedia) && (
            <MediaForm
              user={user}
              setMedia={setMedia}
              setError={setError}
              editingMedia={editingMedia}
              setEditingMedia={setEditingMedia}
              setShowAddForm={setShowAddForm}
            />
          )}

          <Filters filters={filters} setFilters={setFilters} media={media} />

          <MediaList
            media={media}
            filters={filters}
            setMedia={setMedia}
            setError={setError}
            setEditingMedia={setEditingMedia}
            setShowAddForm={setShowAddForm}
          />
        </div>
      );
    }

    // Componente para agregar/editar pel√≠culas/series
    function MediaForm({ user, setMedia, setError, editingMedia, setEditingMedia, setShowAddForm }) {
      const isEditing = !!editingMedia;
      const [title, setTitle] = useState(isEditing ? editingMedia.title : '');
      const [type, setType] = useState(isEditing ? editingMedia.type : 'pel√≠cula');
      const [platform, setPlatform] = useState(isEditing ? editingMedia.platform : '');
      const [genre, setGenre] = useState(isEditing ? editingMedia.genre : '');
      const [duration, setDuration] = useState(isEditing ? editingMedia.duration : '');
      const [status, setStatus] = useState(isEditing ? editingMedia.status : 'por ver');
      const [rating, setRating] = useState(isEditing ? editingMedia.rating || '' : '');
      const [seasons, setSeasons] = useState([]);
      const [customGenre, setCustomGenre] = useState('');
      const [formError, setFormError] = useState('');
      const [availablePlatforms, setAvailablePlatforms] = useState([]);

      useEffect(() => {
        const fetchPlatforms = async () => {
          try {
            const platforms = await db.platforms.orderBy('name').toArray();
            setAvailablePlatforms(platforms.map(p => p.name));
            console.log('Plataformas cargadas para el formulario:', platforms.map(p => p.name));
          } catch (err) {
            setError('Error al cargar plataformas: ' + err.message);
            console.error('Error al cargar plataformas:', err);
          }
        };
        fetchPlatforms();
      }, []);

      useEffect(() => {
        if (isEditing && type === 'serie') {
          const loadSeasons = async () => {
            try {
              const mediaSeasons = await db.seasons.where({ mediaId: editingMedia.id }).toArray();
              const seasonsWithEpisodes = await Promise.all(
                mediaSeasons.map(async s => {
                  const episodes = await db.episodes.where({ seasonId: s.id }).toArray();
                  return {
                    id: s.id,
                    seasonNumber: s.seasonNumber,
                    episodeCount: s.episodeCount,
                    episodes: episodes.map(e => ({
                      id: e.id,
                      episodeNumber: e.episodeNumber,
                      duration: e.duration,
                      watched: e.watched
                    }))
                  };
                })
              );
              setSeasons(seasonsWithEpisodes);
              console.log('Temporadas cargadas para edici√≥n:', seasonsWithEpisodes);
            } catch (err) {
              setError('Error al cargar temporadas para edici√≥n: ' + err.message);
              console.error('Error al cargar temporadas:', err);
            }
          };
          loadSeasons();
        } else {
          setSeasons([]);
        }
      }, [editingMedia, type]);

      const handleAddSeason = () => {
        setSeasons([...seasons, { seasonNumber: seasons.length + 1, episodeCount: 1, episodes: [{ episodeNumber: 1, duration: 0, watched: false }] }]);
        console.log('Temporada a√±adida, total:', seasons.length + 1);
      };

      const handleSeasonChange = (index, field, value) => {
        const newSeasons = [...seasons];
        newSeasons[index][field] = value;
        if (field === 'episodeCount') {
          newSeasons[index].episodes = Array.from({ length: value }, (_, i) => {
            const existingEpisode = newSeasons[index].episodes[i];
            return existingEpisode || { episodeNumber: i + 1, duration: 0, watched: false };
          });
        }
        setSeasons(newSeasons);
        console.log('Temporada actualizada:', newSeasons[index]);
      };

      const handleEpisodeChange = (seasonIndex, episodeIndex, field, value) => {
        const newSeasons = [...seasons];
        newSeasons[seasonIndex].episodes[episodeIndex][field] = field === 'duration' ? parseInt(value) || 0 : value;
        setSeasons(newSeasons);
        console.log('Episodio actualizado:', newSeasons[seasonIndex].episodes[episodeIndex]);
      };

      const handleDelete = async () => {
        if (!isEditing) return;

        const confirmDelete = window.confirm(`¬øEst√°s seguro de que deseas eliminar "${editingMedia.title}"? Esta acci√≥n no se puede deshacer.`);
        if (!confirmDelete) {
          console.log('Eliminaci√≥n cancelada por el usuario');
          return;
        }

        console.log('Eliminando medio:', editingMedia.id);
        try {
          if (editingMedia.type === 'serie') {
            const mediaSeasons = await db.seasons.where({ mediaId: editingMedia.id }).toArray();
            for (const season of mediaSeasons) {
              await db.episodes.where({ seasonId: season.id }).delete();
              await db.seasons.delete(season.id);
            }
          }
          await db.media.delete(editingMedia.id);
          const userMedia = await db.media.where({ userId: user.id }).toArray();
          setMedia(userMedia);
          setEditingMedia(null);
          setShowAddForm(false);
          setFormError('');
          console.log('Medio eliminado, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al eliminar medio: ' + err.message);
          console.error('Error al eliminar medio:', err);
        }
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        console.log(isEditing ? 'Editando medio:' : 'Agregando medio:', title);
        console.log('Plataforma ingresada:', platform);

        if (hasSessionExpired()) {
          console.log('Sesi√≥n expirada al intentar guardar medio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.');
          return;
        }

        if (status === 'visto' && !rating) {
          setFormError('El rating es obligatorio cuando el estado es "visto".');
          console.log('Error: Rating requerido para estado "visto"');
          return;
        }

        if (!platform) {
          setFormError('El campo Plataforma es obligatorio.');
          console.log('Error: Plataforma requerida');
          return;
        }

        try {
          const trimmedPlatform = platform.trim();
          const platformExists = await db.platforms.where({ name: trimmedPlatform }).first();
          if (!platformExists) {
            await db.platforms.add({ name: trimmedPlatform });
            console.log('Nueva plataforma a√±adida:', trimmedPlatform);
            setAvailablePlatforms([...availablePlatforms, trimmedPlatform].sort());
          }

          const finalGenre = genre === 'Otro' ? customGenre : genre;
          const mediaId = isEditing ? editingMedia.id : generateId();

          if (isEditing) {
            console.log('Actualizando medio en IndexedDB:', { id: mediaId, platform });
            await db.media.update(mediaId, {
              title,
              type,
              platform: trimmedPlatform,
              genre: finalGenre,
              duration: parseInt(duration) || 0,
              status,
              rating: rating ? parseInt(rating) : null
            });

            if (type === 'serie') {
              const existingSeasons = await db.seasons.where({ mediaId }).toArray();
              for (const season of existingSeasons) {
                await db.episodes.where({ seasonId: season.id }).delete();
                await db.seasons.delete(season.id);
              }

              for (const season of seasons) {
                const seasonId = season.id || generateId();
                const totalDuration = season.episodes.reduce((sum, ep) => sum + (ep.duration || 0), 0);
                await db.seasons.add({
                  id: seasonId,
                  mediaId,
                  seasonNumber: season.seasonNumber,
                  episodeCount: season.episodeCount,
                  totalDuration
                });

                for (const episode of season.episodes) {
                  const episodeId = episode.id || generateId();
                  await db.episodes.add({
                    id: episodeId,
                    seasonId,
                    episodeNumber: episode.episodeNumber,
                    duration: episode.duration || 0,
                    watched: episode.watched
                  });
                }
              }
            }
          } else {
            console.log('Guardando nuevo medio en IndexedDB:', { id: mediaId, platform });
            await db.media.add({
              id: mediaId,
              userId: user.id,
              title,
              type,
              platform: trimmedPlatform,
              genre: finalGenre,
              duration: parseInt(duration) || 0,
              status,
              rating: rating ? parseInt(rating) : null
            });

            if (type === 'serie') {
              for (const season of seasons) {
                const seasonId = generateId();
                const totalDuration = season.episodes.reduce((sum, ep) => sum + (ep.duration || 0), 0);
                await db.seasons.add({
                  id: seasonId,
                  mediaId,
                  seasonNumber: season.seasonNumber,
                  episodeCount: season.episodeCount,
                  totalDuration
                });

                for (const episode of season.episodes) {
                  const episodeId = generateId();
                  await db.episodes.add({
                    id: episodeId,
                    seasonId,
                    episodeNumber: episode.episodeNumber,
                    duration: episode.duration || 0,
                    watched: episode.watched
                  });
                }
              }
            }
          }

          const userMedia = await db.media.where({ userId: user.id }).toArray();
          console.log('Medios recargados despu√©s de guardar:', userMedia);
          setMedia(userMedia);

          setTitle('');
          setType('pel√≠cula');
          setPlatform('');
          setGenre('');
          setDuration('');
          setStatus('por ver');
          setRating('');
          setSeasons([]);
          setCustomGenre('');
          setEditingMedia(null);
          setShowAddForm(false);
          setFormError('');
          console.log(isEditing ? 'Medio actualizado:' : 'Medio a√±adido:', { id: mediaId, title, platform });
          updateLastActivity();
        } catch (err) {
          setError((isEditing ? 'Error al editar medio: ' : 'Error al agregar medio: ') + err.message);
          console.error('Error:', err);
        }
      };

      return (
        <form onSubmit={handleSubmit} class="card">
          <h2 style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '20px' }}>
            {isEditing ? 'Editar Pel√≠cula/Serie' : 'Agregar Pel√≠cula/Serie'}
          </h2>
          {formError && <p class="error">{formError}</p>}
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
            <div class="form-group">
              <label>T√≠tulo</label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
              />
            </div>
            <div class="form-group">
              <label>Tipo</label>
              <select value={type} onChange={(e) => setType(e.target.value)}>
                <option value="pel√≠cula">Pel√≠cula</option>
                <option value="serie">Serie</option>
              </select>
            </div>
            <div class="form-group">
              <label>Plataforma</label>
              <input
                type="text"
                list="platform-suggestions"
                value={platform}
                onChange={(e) => setPlatform(e.target.value)}
                required
              />
              <datalist id="platform-suggestions">
                {availablePlatforms.map(p => <option key={p} value={p} />)}
              </datalist>
            </div>
            <div class="form-group">
              <label>G√©nero</label>
              <select value={genre} onChange={(e) => setGenre(e.target.value)}>
                <option value="">Selecciona G√©nero</option>
                {genres.map(g => <option key={g} value={g}>{g}</option>)}
              </select>
              {genre === 'Otro' && (
                <input
                  type="text"
                  placeholder="G√©nero personalizado"
                  value={customGenre}
                  onChange={(e) => setCustomGenre(e.target.value)}
                  style={{ marginTop: '10px' }}
                  required
                />
              )}
            </div>
            <div class="form-group">
              <label>Duraci√≥n (minutos)</label>
              <input
                type="number"
                value={duration}
                onChange={(e) => setDuration(e.target.value)}
                required={type === 'pel√≠cula'}
              />
            </div>
            <div class="form-group">
              <label>Estado</label>
              <select value={status} onChange={(e) => setStatus(e.target.value)}>
                <option value="visto">Visto</option>
                <option value="viendo">Viendo</option>
                <option value="por ver">Por Ver</option>
              </select>
            </div>
            <div class="form-group">
              <label>Rating (1-5)</label>
              <select
                value={rating}
                onChange={(e) => setRating(e.target.value)}
                required={status === 'visto'}
              >
                <option value="">Sin calificar</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
          </div>

          {type === 'serie' && (
            <div style={{ marginTop: '20px' }}>
              <h3 style={{ fontSize: '1.1rem', fontWeight: 'bold' }}>Temporadas</h3>
              <button
                type="button"
                onClick={handleAddSeason}
                class="button button-blue"
                style={{ margin: '10px 0' }}
              >
                Agregar Temporada
              </button>
              {seasons.map((season, sIndex) => (
                <div key={sIndex} class="card" style={{ marginTop: '10px', background: '#f9f9f9' }}>
                  <h4 style={{ fontWeight: 'bold' }}>Temporada {season.seasonNumber}</h4>
                  <div class="form-group">
                    <label>N√∫mero de episodios</label>
                    <input
                      type="number"
                      value={season.episodeCount}
                      onChange={(e) => handleSeasonChange(sIndex, 'episodeCount', parseInt(e.target.value))}
                      min="1"
                      required
                    />
                  </div>
                  {season.episodes.map((episode, eIndex) => (
                    <div key={eIndex} class="flex" style={{ marginTop: '10px' }}>
                      <span style={{ flex: '1' }}>Episodio {episode.episodeNumber}</span>
                      <input
                        type="number"
                        placeholder="Duraci√≥n (min)"
                        value={episode.duration}
                        onChange={(e) => handleEpisodeChange(sIndex, eIndex, 'duration', e.target.value)}
                        style={{ width: '100px' }}
                        min="0"
                      />
                      <label>
                        <input
                          type="checkbox"
                          checked={episode.watched}
                          onChange={(e) => handleEpisodeChange(sIndex, eIndex, 'watched', e.target.checked)}
                        />
                        Visto
                      </label>
                    </div>
                  ))}
                </div>
              ))}
            </div>
          )}

          <div class="flex" style={{ marginTop: '20px', gap: '10px' }}>
            <button type="submit" class="button button-blue">
              {isEditing ? 'Guardar Cambios' : 'Agregar'}
            </button>
            {isEditing && (
              <button
                type="button"
                onClick={handleDelete}
                class="button button-red"
              >
                Eliminar
              </button>
            )}
            <button
              type="button"
              onClick={() => {
                setEditingMedia(null);
                setShowAddForm(false);
                setFormError('');
                console.log('Formulario cerrado - showAddForm:', false, 'editingMedia:', null);
                updateLastActivity();
              }}
              class="button button-gray"
            >
              Cancelar
            </button>
          </div>
        </form>
      );
    }

    // Componente de Filtros
    function Filters({ filters, setFilters, media }) {
      const [availablePlatforms, setAvailablePlatforms] = useState([]);

      useEffect(() => {
        const fetchPlatforms = async () => {
          try {
            const platforms = await db.platforms.orderBy('name').toArray();
            const platformNames = platforms.map(p => p.name);
            console.log('Plataformas disponibles para filtros:', platformNames);
            setAvailablePlatforms(platformNames);
          } catch (err) {
            console.error('Error al cargar plataformas para filtros:', err);
          }
        };
        fetchPlatforms();
      }, []);

      return (
        <div class="card">
          <h2 style={{ fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '20px' }}>Filtros</h2>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px' }}>
            <div class="form-group">
              <label>Plataforma</label>
              <select
                value={filters.platform}
                onChange={(e) => setFilters({ ...filters, platform: e.target.value })}
              >
                <option value="">Todas las Plataformas</option>
                {availablePlatforms.map(p => <option key={p} value={p}>{p}</option>)}
              </select>
            </div>
            <div class="form-group">
              <label>Tipo</label>
              <select
                value={filters.type}
                onChange={(e) => setFilters({ ...filters, type: e.target.value })}
              >
                <option value="">Pel√≠culas y Series</option>
                <option value="pel√≠cula">Pel√≠cula</option>
                <option value="serie">Serie</option>
              </select>
            </div>
            <div class="form-group">
              <label>G√©nero</label>
              <select
                value={filters.genre}
                onChange={(e) => setFilters({ ...filters, genre: e.target.value })}
              >
                <option value="">Todos los G√©neros</option>
                {genres.map(g => <option key={g} value={g}>{g}</option>)}
              </select>
            </div>
            <div class="form-group">
              <label>Estado</label>
              <select
                value={filters.status}
                onChange={(e) => setFilters({ ...filters, status: e.target.value })}
              >
                <option value="">Todos los Estados</option>
                <option value="visto">Visto</option>
                <option value="viendo">Viendo</option>
                <option value="por ver">Por Ver</option>
              </select>
            </div>
          </div>
        </div>
      );
    }

    // Componente de Lista de Medios
    function MediaList({ media, filters, setMedia, setError, setEditingMedia, setShowAddForm }) {
      const [mediaWithTime, setMediaWithTime] = useState([]);

      useEffect(() => {
        const calculateWatchedTime = async () => {
          console.log('Calculando tiempo visto para medios:', media);
          try {
            const updatedMedia = await Promise.all(media.map(async m => {
              const totalTime = await getTotalWatchedTime(m.id, m.type);
              return { ...m, totalWatchedTime: totalTime };
            }));
            setMediaWithTime(updatedMedia);
            console.log('Medios con tiempo calculado:', updatedMedia);
          } catch (err) {
            setError('Error al calcular tiempo visto: ' + err.message);
            console.error('Error al calcular tiempo visto:', err);
          }
        };
        calculateWatchedTime();
      }, [media]);

      const filteredMedia = mediaWithTime.filter(m => {
        return (
          (!filters.platform || m.platform === filters.platform) &&
          (!filters.type || m.type === filters.type) &&
          (!filters.genre || m.genre === filters.genre) &&
          (!filters.status || m.status === filters.status)
        );
      });

      const handleStatusChange = async (mediaId, newStatus) => {
        console.log('Actualizando estado del medio:', mediaId, newStatus);
        if (hasSessionExpired()) {
          console.log('Sesi√≥n expirada al intentar cambiar estado');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.');
          return;
        }

        try {
          const mediaItem = await db.media.get(mediaId);
          if (newStatus === 'visto' && !mediaItem.rating) {
            setError('Debes seleccionar un rating antes de marcar este medio como "visto".');
            console.log('Error: Rating requerido para estado "visto"');
            return;
          }
          await db.media.update(mediaId, { status: newStatus });
          const userMedia = await db.media.where({ userId: media[0].userId }).toArray();
          setMedia(userMedia);
          console.log('Estado actualizado, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al actualizar estado: ' + err.message);
          console.error('Error al actualizar estado:', err);
        }
      };

      const handleEpisodeToggle = async (episodeId, watched) => {
        console.log('Actualizando episodio:', episodeId, watched);
        if (hasSessionExpired()) {
          console.log('Sesi√≥n expirada al intentar actualizar episodio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.');
          return;
        }

        try {
          await db.episodes.update(episodeId, { watched });
          const userMedia = await db.media.where({ userId: media[0].userId }).toArray();
          setMedia(userMedia);
          console.log('Episodio actualizado, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al actualizar episodio: ' + err.message);
          console.error('Error al actualizar episodio:', err);
        }
      };

      const handleEdit = (mediaItem) => {
        if (hasSessionExpired()) {
          console.log('Sesi√≥n expirada al intentar editar medio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesi√≥n ha expirada. Por favor, inicia sesi√≥n nuevamente.');
          return;
        }

        setEditingMedia(mediaItem);
        setShowAddForm(false);
        console.log('Editando medio:', mediaItem.id, 'showAddForm:', false, 'editingMedia:', mediaItem);
        window.scrollTo({ top: 0, behavior: 'smooth' });
        updateLastActivity();
      };

      const handleDelete = async (mediaItem) => {
        if (hasSessionExpired()) {
          console.log('Sesi√≥n expirada al intentar eliminar medio');
          localStorage.removeItem('userId');
          localStorage.removeItem('lastActivity');
          setError('Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.');
          return;
        }

        const confirmDelete = window.confirm(`¬øEst√°s seguro de que deseas eliminar "${mediaItem.title}"? Esta acci√≥n no se puede deshacer.`);
        if (!confirmDelete) {
          console.log('Eliminaci√≥n cancelada por el usuario');
          return;
        }

        console.log('Eliminando medio desde lista:', mediaItem.id);
        try {
          if (mediaItem.type === 'serie') {
            const mediaSeasons = await db.seasons.where({ mediaId: mediaItem.id }).toArray();
            for (const season of mediaSeasons) {
              await db.episodes.where({ seasonId: season.id }).delete();
              await db.seasons.delete(season.id);
            }
          }
          await db.media.delete(mediaItem.id);
          const userMedia = await db.media.where({ userId: media[0].userId }).toArray();
          setMedia(userMedia);
          console.log('Medio eliminado desde lista, medios recargados:', userMedia);
          updateLastActivity();
        } catch (err) {
          setError('Error al eliminar medio desde lista: ' + err.message);
          console.error('Error al eliminar medio desde lista:', err);
        }
      };

      const getTotalWatchedTime = async (mediaId, type) => {
        try {
          if (type === 'pel√≠cula') {
            const m = await db.media.get(mediaId);
            return m.status === 'visto' ? m.duration : 0;
          } else {
            const seasons = await db.seasons.where({ mediaId }).toArray();
            let total = 0;
            for (const season of seasons) {
              const episodes = await db.episodes.where({ seasonId: season.id }).toArray();
              total += episodes.reduce((sum, ep) => sum + (ep.watched ? ep.duration : 0), 0);
            }
            return total;
          }
        } catch (err) {
          console.error('Error al calcular tiempo visto para medio:', mediaId, err);
          return 0;
        }
      };

      return (
        <div class="grid">
          {filteredMedia.length > 0 ? filteredMedia.map(m => (
            <div key={m.id} class="card">
              <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>{m.title}</h3>
              <p>Tipo: {m.type}</p>
              <p class="platform-highlight">Plataforma: {m.platform}</p>
              <p>G√©nero: {m.genre}</p>
              <p>Duraci√≥n: {m.duration} min</p>
              <p>Tiempo Visto: {m.totalWatchedTime} min</p>
              <p>Rating: {m.rating ? m.rating + '/5' : 'Sin calificar'}</p>
              <div class="form-group">
                <label>Estado</label>
                <select
                  value={m.status}
                  onChange={(e) => handleStatusChange(m.id, e.target.value)}
                >
                  <option value="visto">Visto</option>
                  <option value="viendo">Viendo</option>
                  <option value="por ver">Por Ver</option>
                </select>
              </div>
              <div class="flex" style={{ marginTop: '10px' }}>
                <button
                  onClick={() => handleEdit(m)}
                  class="button button-blue"
                >
                  Editar
                </button>
                <button
                  onClick={() => handleDelete(m)}
                  class="button button-red"
                >
                  Eliminar
                </button>
              </div>
              {m.type === 'serie' && (
                <SeriesDetails mediaId={m.id} handleEpisodeToggle={handleEpisodeToggle} />
              )}
            </div>
          )) : (
            <p style={{ color: '#666' }}>No hay medios que coincidan con los filtros.</p>
          )}
        </div>
      );
    }

    // Componente de Detalles de Series
    function SeriesDetails({ mediaId, handleEpisodeToggle }) {
      const [seasons, setSeasons] = useState([]);

      useEffect(() => {
        const fetchSeasons = async () => {
          console.log('Cargando temporadas para medio:', mediaId);
          try {
            const seasons = await db.seasons.where({ mediaId }).toArray();
            const seasonsWithEpisodes = await Promise.all(
              seasons.map(async s => {
                const episodes = await db.episodes.where({ seasonId: s.id }).toArray();
                return { ...s, episodes, completed: episodes.every(e => e.watched) };
              })
            );
            setSeasons(seasonsWithEpisodes);
            console.log('Temporadas cargadas:', seasonsWithEpisodes);
          } catch (err) {
            console.error('Error al cargar temporadas:', err);
          }
        };
        fetchSeasons();
      }, [mediaId]);

      return (
        <div style={{ marginTop: '20px' }}>
          <h4 style={{ fontWeight: 'bold' }}>Temporadas</h4>
          {seasons.length > 0 ? seasons.map(s => (
            <div key={s.id} style={{ marginTop: '10px' }}>
              <p>Temporada {s.seasonNumber} {s.completed ? '(Completada)' : ''}</p>
              {s.episodes.map(e => (
                <div key={e.id} class="flex" style={{ marginTop: '5px' }}>
                  <input
                    type="checkbox"
                    checked={e.watched}
                    onChange={() => handleEpisodeToggle(e.id, !e.watched)}
                  />
                  <span>Episodio {e.episodeNumber} ({e.duration} min)</span>
                </div>
              ))}
            </div>
          )) : (
            <p style={{ color: '#666' }}>No hay temporadas registradas.</p>
          )}
        </div>
      );
    }

    // Renderizar la aplicaci√≥n
    try {
      console.log('Renderizando aplicaci√≥n...');
      ReactDOM.render(<App />, document.getElementById('root'));
      console.log('Aplicaci√≥n renderizada exitosamente');
    } catch (err) {
      console.error('Error al renderizar la aplicaci√≥n:', err);
      document.getElementById('root').innerHTML = '<p class="error" style="padding: 20px;">Error al cargar la aplicaci√≥n. Por favor, revisa la consola del navegador para m√°s detalles.</p>';
    }
  </script>
</body>
</html>
